// machine.cc 
//	Routines for simulating the execution of user programs.
//
//  DO NOT CHANGE -- part of the machine emulation
//
// Copyright (c) 1992-1993 The Regents of the University of California.
// All rights reserved.  See copyright.h for copyright notice and limitation 
// of liability and disclaimer of warranty provisions.

#include "copyright.h"
#include "machine.h"
#include "system.h"
//#include "noff.h"

int pointerClock=0;
int TLBMissNumber=0;
int TLBTranslateNumber=0;
static int findHead(int virAddr,NoffHeader noffH);
static bool lazyLoading(int virAddr,int phyAddr,int size,bool isWrite);
// Textual names of the exceptions that can be generated by user program
// execution, for debugging.
static char* exceptionNames[] = { "no exception", "syscall", 
				"page fault/no TLB entry", "page read only",
				"bus error", "address error", "overflow",
				"illegal instruction" };

//----------------------------------------------------------------------
// CheckEndian
// 	Check to be sure that the host really uses the format it says it 
//	does, for storing the bytes of an integer.  Stop on error.
//----------------------------------------------------------------------

static
void CheckEndian()
{
    union checkit {
        char charword[4];
        unsigned int intword;
    } check;

    check.charword[0] = 1;
    check.charword[1] = 2;
    check.charword[2] = 3;
    check.charword[3] = 4;

#ifdef HOST_IS_BIG_ENDIAN
    ASSERT (check.intword == 0x01020304);
#else
    ASSERT (check.intword == 0x04030201);
#endif
}

//----------------------------------------------------------------------
// Machine::Machine
// 	Initialize the simulation of user program execution.
//
//	"debug" -- if TRUE, drop into the debugger after each user instruction
//		is executed.
//----------------------------------------------------------------------

Machine::Machine(bool debug)
{
    int i;

    for (i = 0; i < NumTotalRegs; i++)
        registers[i] = 0;
    mainMemory = new char[MemorySize];
    for (i = 0; i < MemorySize; i++)
      	mainMemory[i] = 0;
#ifdef USE_TLB
    tlb = new TranslationEntry[TLBSize];
    for (i = 0; i < TLBSize; i++)
	tlb[i].valid = FALSE;
    pageTable = NULL;
#else	// use linear page table
    tlb = NULL;
    pageTable = NULL;
#endif
#ifdef USE_BITMAP
    bitmap=new BitMap(NumPhysPages);
#else  //REVERSE_PAGE
    pageTable = new TranslationEntry[NumPhysPages];
    // Initialize Inverted Page Table
    for (i = 0; i < NumPhysPages; i++) {
        pageTable[i].physicalPage = i;
        pageTable[i].virtualPage = i;
        pageTable[i].valid = FALSE;
        pageTable[i].dirty = FALSE;
        pageTable[i].readOnly = FALSE;
        pageTable[i].tid = -1;
    }
    pageTableSize = MemorySize;
#endif


    singleStep = debug;
    CheckEndian();
}

//----------------------------------------------------------------------
// Machine::~Machine
// 	De-allocate the data structures used to simulate user program execution.
//----------------------------------------------------------------------

Machine::~Machine()
{
    delete [] mainMemory;
    if (tlb != NULL)
        delete [] tlb;
    if (bitmap != NULL)
        delete bitmap;
}

//----------------------------------------------------------------------
// Machine::RaiseException
// 	Transfer control to the Nachos kernel from user mode, because
//	the user program either invoked a system call, or some exception
//	occured (such as the address translation failed).
//
//	"which" -- the cause of the kernel trap
//	"badVaddr" -- the virtual address causing the trap, if appropriate
//----------------------------------------------------------------------

void
Machine::RaiseException(ExceptionType which, int badVAddr)
{
    DEBUG('m', "Exception: %s\n", exceptionNames[which]);
    
//  ASSERT(interrupt->getStatus() == UserMode);
    registers[BadVAddrReg] = badVAddr;
    DelayedLoad(0, 0);			// finish anything in progress
    interrupt->setStatus(SystemMode);
    ExceptionHandler(which);		// interrupts are enabled at this point
    interrupt->setStatus(UserMode);
}

//----------------------------------------------------------------------
// Machine::Debugger
// 	Primitive debugger for user programs.  Note that we can't use
//	gdb to debug user programs, since gdb doesn't run on top of Nachos.
//	It could, but you'd have to implement *a lot* more system calls
//	to get it to work!
//
//	So just allow single-stepping, and printing the contents of memory.
//----------------------------------------------------------------------

void Machine::Debugger()
{
    char *buf = new char[80];
    int num;

    interrupt->DumpState();
    DumpState();
    printf("%d> ", stats->totalTicks);
    fflush(stdout);
    fgets(buf, 80, stdin);
    if (sscanf(buf, "%d", &num) == 1)
	runUntilTime = num;
    else {
	runUntilTime = 0;
	switch (*buf) {
	  case '\n':
	    break;
	    
	  case 'c':
	    singleStep = FALSE;
	    break;
	    
	  case '?':
	    printf("Machine commands:\n");
	    printf("    <return>  execute one instruction\n");
	    printf("    <number>  run until the given timer tick\n");
	    printf("    c         run until completion\n");
	    printf("    ?         print help message\n");
	    break;
	}
    }
    delete [] buf;
}
 
//----------------------------------------------------------------------
// Machine::DumpState
// 	Print the user program's CPU state.  We might print the contents
//	of memory, but that seemed like overkill.
//----------------------------------------------------------------------

void
Machine::DumpState()
{
    int i;
    
    printf("Machine registers:\n");
    for (i = 0; i < NumGPRegs; i++)
	switch (i) {
	  case StackReg:
	    printf("\tSP(%d):\t0x%x%s", i, registers[i],
		   ((i % 4) == 3) ? "\n" : "");
	    break;
	    
	  case RetAddrReg:
	    printf("\tRA(%d):\t0x%x%s", i, registers[i],
		   ((i % 4) == 3) ? "\n" : "");
	    break;
	  
	  default:
	    printf("\t%d:\t0x%x%s", i, registers[i],
		   ((i % 4) == 3) ? "\n" : "");
	    break;
	}
    
    printf("\tHi:\t0x%x", registers[HiReg]);
    printf("\tLo:\t0x%x\n", registers[LoReg]);
    printf("\tPC:\t0x%x", registers[PCReg]);
    printf("\tNextPC:\t0x%x", registers[NextPCReg]);
    printf("\tPrevPC:\t0x%x\n", registers[PrevPCReg]);
    printf("\tLoad:\t0x%x", registers[LoadReg]);
    printf("\tLoadV:\t0x%x\n", registers[LoadValueReg]);
    printf("\n");
}

//----------------------------------------------------------------------
// Machine::ReadRegister/WriteRegister
//   	Fetch or write the contents of a user program register.
//----------------------------------------------------------------------

int Machine::ReadRegister(int num)
    {
	ASSERT((num >= 0) && (num < NumTotalRegs));
	return registers[num];
    }

void Machine::WriteRegister(int num, int value)
    {
	ASSERT((num >= 0) && (num < NumTotalRegs));
	// DEBUG('m', "WriteRegister %d, value %d\n", num, value);
	registers[num] = value;
    }

void
Machine::TLBLRUSwap(int addr) {
    DEBUG('m',"=> TLB miss, LRU algorithm swap\n");
    unsigned int vpn = (unsigned ) addr / PageSize;  //virtual page number
    int minTime = tlb[0].lastUseTime;  //find Longest unused tlb
    TranslationEntry *entry = &tlb[0];

    for(int i=0; i < TLBSize; i++){
        if(!tlb[i].valid) { //If there is an empty page, go back directly
            entry = &tlb[i];
            break;
        }else{
            if(tlb[i].lastUseTime < minTime){			//找到时间最小的一项，即为需要置换的项
                minTime = tlb[i].lastUseTime;
                entry = &tlb[i];
            }
        }
    }

//    if(entry->valid) pageTable[entry->virtualPage] = *entry; //if no empty,swap
#ifdef USE_DP
    if(!(pageTable[vpn].valid)){
        demandPaging(vpn);
    }
#endif
    *entry = pageTable[vpn];
    entry->lastUseTime = stats->totalTicks;
}

void
Machine::TLBClockSwap(int addr){

    unsigned int vpn = (unsigned ) addr / PageSize;  //virtual page number
    while(1){
        pointerClock %= TLBSize;
        if(!tlb[pointerClock].valid){ // have empty page
            break;
        }else{
            if(tlb[pointerClock].use){
                tlb[pointerClock].use = false;
                pointerClock++;
            }else{
                break;
            }
        }
    }
#ifdef USE_DP
    if(!(pageTable[vpn].valid)){
        demandPaging(vpn);
    }
#endif
    tlb[pointerClock] = pageTable[vpn];
    tlb[pointerClock].use = true;
    currentThread->space->PrintState(); // debug with -d M to show bitmap
}

int
Machine::allocateMemory(){
#ifndef REVERSE_PAGE
    int bit = bitmap->Find();
    if(bit!=-1) {
        printf("allocate memory,page frame number: %d\n",bit);
        bitmap->Mark(bit);
    }
    else DEBUG('m',"Out of memory\n");
    return bit;
#else
    for (int bit = 0; bit < NumPhysPages; bit++) {
        if (!pageTable[bit].valid) {
            printf("inverse allocate memory,page frame number: %d\n",bit);
            return bit;
        }
    }
    printf("out of memory\n");
    return -1;
#endif
}


void
Machine::freeMemory(){
#ifndef REVERSE_PAGE
    for(int i=0; i < pageTableSize; i++){
        if(pageTable[i].valid){
            int pageFrameNum = pageTable[i].physicalPage;
            bitmap->Clear(pageFrameNum);
            pageTable[i].valid = FALSE;
            printf("free memory,page frame number: %d\n",pageFrameNum);
        }
    }
#else
    for (int i = 0; i < NumPhysPages; i++) {
        if (pageTable[i].tid == currentThread->getTid()) {
            pageTable[i].valid = FALSE;
            printf("free memory,page frame number: %d\n",i);
        }
    }
    printf("free thread id is %d\n", currentThread->getTid());
#endif
}

void
Machine::demandPaging(int vpn) {
    int pageNum = allocateMemory();
    if(pageNum == -1){ //缺页中断
        printf("load from disk\n");
        for(int i = 0;i < pageTableSize;i++){
            if (pageTable[i].valid) {
                if (!(pageTable[i].dirty)) {
                    pageTable[i].valid = FALSE;
                    pageNum = pageTable[i].physicalPage;
                    printf("swap page num:%d\n",pageNum);
                    break;
                }
            }
        }
        if (pageNum == -1){
            for (int i = 0; i < pageTableSize ; i++) {
                if (pageTable[i].valid) {
                    pageTable[i].valid = FALSE;
                    pageNum = pageTable[i].physicalPage;
                    printf("swap page num:%d\n",pageNum);
                    // Store the page back to vm
                    if(!lazyLoading(i*PageSize, pageNum*PageSize,PageSize, true)){
                        return;
                    }
                    break;
                }
            }
        }
    }
    pageTable[vpn].physicalPage = pageNum;

    if(pageNum >= NumPhysPages || vpn >= pageTableSize){
        printf("vpn out of bound\n");
        ASSERT(FALSE);
    }
    lazyLoading(vpn*PageSize, pageNum * PageSize, PageSize, false);
    pageTable[vpn].valid = TRUE;
    pageTable[vpn].use = FALSE;
    pageTable[vpn].dirty = FALSE;
    pageTable[vpn].readOnly = FALSE;

//    currentThread->space->PrintState();
}

static bool
lazyLoading(int virAddr,int phyAddr,int size,bool isWrite){
    OpenFile *executable = currentThread->space->executable;
    NoffHeader noffH = currentThread->space->noffH;
    if(executable == NULL){
        printf("无可执行文件的缓存\n");
        return false;
    }
    if (isWrite){
        executable->WriteAt(&(machine->mainMemory[phyAddr]), size, findHead(virAddr,noffH));
    }else{
//        unsigned int vpn = virAddr / PageSize;
//        if(vpn == noffH.code.size + noffH.initData.size + noffH.uninitData.size)
//        size = noffH.code.size + noffH.initData.size + noffH.uninitData.size
//               + UserStackSize -
//        printf("懒加载的地方:%d，物理地址:%d\n",virAddr,phyAddr);
//        printf("noffH.code.virtual: %d, noffH.code.size: %d,noffH.code.inFileAddr: %d,\n",noffH.code.virtualAddr,noffH.code.size,noffH.code.inFileAddr);
//        printf("物理地址： %d, 大小: %d, 文件偏移: %d,\n",phyAddr,size,findHead(virAddr,noffH));
        executable->ReadAt(&(machine->mainMemory[phyAddr]), size, findHead(virAddr, noffH));

    }
    return true;
}

static int
findHead(int virAddr,NoffHeader noffH){
    if(noffH.code.size > 0){
        int size = noffH.code.size;
        if((virAddr >= noffH.code.virtualAddr) && (virAddr < (noffH.code.virtualAddr + size))){
            return noffH.code.inFileAddr + virAddr;
        }
    }
    if(noffH.initData.size > 0){
        int size = noffH.initData.size;
        if( (virAddr >=noffH.initData.virtualAddr) && (virAddr < (noffH.initData.virtualAddr + size))){
            return noffH.initData.inFileAddr + virAddr;
        }
    }
    return virAddr/10;
}


